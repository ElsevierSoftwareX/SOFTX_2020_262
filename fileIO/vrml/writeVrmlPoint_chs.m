
function writeVrmlPoint_chs(aX, aY, aZ,TS, varargin)

p = inputParser;

thr_min_def= nanmin(TS(:));
thr_max_def= nanmax(TS(:));
%filename, seuilE, seuilMx, seuilMn

addRequired(p,'aX',@isnumeric);
addRequired(p,'aY',@isnumeric);
addRequired(p,'aZ',@isnumeric);
addRequired(p,'TS',@isnumeric);
addParameter(p,'filename',fullfile(pwd,'data.vrml'),@ischar);
addParameter(p,'thr_min',thr_min_def,@isnumeric);
addParameter(p,'thr_max',thr_max_def,@isnumeric);
addParameter(p,'cmap_name','ek60',@ischar);

parse(p,aX, aY, aZ,TS,varargin{:});

filename=p.Results.filename;
thr_min=p.Results.thr_min;
thr_max=p.Results.thr_max;

[cmap,col_ax,col_lab,col_grid,col_bot,col_txt,~]=init_cmap(p.Results.cmap_name);

global fout
nbP = size(aX,1);

aX=aX-nanmin(aX(:));
aY=aY-nanmin(aY(:));


fout = fopen(filename,'w');
sendStr(0,'#VRML V2.0 utf8');
%sendStr(0, sprintf('Inline { url "%s" }', p.Results.filename));
sendStr(0,'WorldInfo {');
sendStr(1,'info "Generated by ESP3"');
sendStr(0,'}\n\n');

sendStr(0,'NavigationInfo {');
sendStr(1,'headlight TRUE');
sendStr(1,'type "EXAMINE"');
sendStr(0,'}\n\n');

%% Lumière

sendStr(0,'DirectionalLight {');
sendStr(1,'intensity 1');
sendStr(1,'color 1 1 1');
sendStr(1,'ambientIntensity 0.5');
sendStr(1,sprintf('direction %f %f %f',  0.5, 0.5,0.5));
sendStr(0,'}\n\n');

%% Couleur du fond

sendStr(0,'Background {');
sendStr(1,'skyColor 0 0 0');
sendStr(0,'}\n\n'); % fond noire

% sendStr(0,'Viewpoint {');
% sendStr(1,sprintf('position %f %f %f', nanmin(aX(:)), nanmin(aY(:)) ,0));
% sendStr(1,sprintf('orientation 0.5 0.5 0 %f', 0)); % rotation autour de X de Pi/2
% sendStr(1,sprintf('fieldOfView %f',1.57));
% sendStr(1,'description "Above"');
% sendStr(0,'}\n\n');%viewpoint

%% Definition et ouverture du groupe Surface

sendStr(0,sprintf('Transform { '));
sendStr(1,sprintf('translation %.1f %.1f %.1f', 0, 0, mean(aZ(:))));
sendStr(1,sprintf('scale %d %d %d', 1, 1, 1));    % Echelle de représentation
sendStr(1,'children [');

sendStr(0,'#-------- Samples  -----------#\n\n');
sendStr(2,'Shape {\n');
sendStr(3,'geometry PointSet {\n');
sendStr(4,'coord Coordinate{\n');
sendStr(5,'point [\n');
   
for ij=1:nbP
    ind = find(TS(ij,:)>thr_min & ~isnan(TS(ij,:)));
    xyz = [aX(ij,ind); aY(ij,ind) ; aZ(ij,ind)];
    sendStr(6,sprintf('%f %f %f,\n',xyz));
end
sendStr(4,']\n');%point
sendStr(2,'}\n');%Coordinate

sendStr(4,'color Color {\n');
sendStr(5,'color [\n');

nbc = size(cmap,1);

%map = [map; 0 0 0]; % on ajoute la couleur noire pour les valeurs NaN;

for ij=1:nbP
    ind = (TS(ij,:)>thr_min & ~isnan(TS(ij,:)));    
    jnd = round((TS(ij,ind)-thr_min)/(thr_max-thr_min)*(nbc-1))+1;
    
    tmp = (jnd<=0);
    jnd(tmp) = 1;
    tmp = (jnd>nbc);
    jnd(tmp) = nbc;
    
    inc = cmap(jnd,:)';
    sendStr(6,sprintf('%f %f %f,\n',inc));
end

sendStr(4,']}\n');%color
sendStr(3,'}\n');%geometry
sendStr(2,'}\n');%shape
sendStr(1,'] # Children\n'); % Children
sendStr(0,'} # Transform\n');% Transform

fclose(fout);




function sendStr(indent,str)
global fout;
tabs = '                    ';
if indent>0
    fprintf(fout,tabs(1:indent));
end
fprintf(fout,str);